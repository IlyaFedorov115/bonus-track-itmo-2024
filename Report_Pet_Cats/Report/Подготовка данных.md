
> Был взят следующий датасет: [Cat breeds details (kaggle.com)](https://www.kaggle.com/datasets/warcoder/cat-breeds-details)

![[Pasted image 20231212130221.png]]

У него есть две проблемы. 1-я - Это столбец `length`, т.к. он задан очень по разному. 2-я это столбец `origin`. Тут и разное представление стран, и перечисление их через запятую, и указание города, а где то и без него. Бардак.

В общем решено сделать что-то вроде этого:
![[Pasted image 20231212135457.png]]

На текущий момент список выглядит так:
![[Pasted image 20231212135534.png]]


**Решим вторую проблему**

Сначала разобьем все части с помощью следующей функции:
```python
def process_row(row):
    res = []
    if 'and' in row:
        res = row.split(' and')
    elif ',' in row:
        res = row.split(',')
    else:
        res = [row]
    res = [e.strip() for e in res]
    return res
```
И применим ее: `df1['origin'] = df1['origin'].apply(process_row)`

Затем изменим азию:

```python
southeast_asia_countries = ["Brunei","Cambodia","East Timor","Indonesia","Laos","Malaysia","Myanmar","Philippines","Singapore","Thailand","Vietnam"
]
index_of_target = list(df1[df1['origin'].apply(lambda x: x == ['Southeast Asia'])].index[:])
df1.loc[index_of_target, 'origin'] = df1.loc[index_of_target, 'origin'].apply(lambda x: southeast_asia_countries)
```

Для некоторых дальнейших действий полезно было бы узнать, сколько пород представлено (например, т.к. во втором наборе их больше). Может показаться, что это просто длина набора, но нет.
```python
len(df1['name']) #62
len(set(df1['name'])) #61
```
Что не так? Сделаем следующее:
```python
from collections import Counter
c = Counter(list(df1['name']))
print(c) #Counter({'American Shorthair': 2, 'Abyssinian': 1, 'Aegean': 1...
```
У нас оказывается повторяющееся значение. Что же это:
`df1.loc[df1['name'] == 'American Shorthair']`
![[Pasted image 20231214193439.png]]
Полностью повторяющаяся строка. 
Поэтому, **перед тем, как переводить origin к списку**, нужно применить удаление дубликатов:
```python
df1.drop_duplicates(inplace=True)
```
Теперь переименуем USA, UK. Упростим
```python
change_names = {
    'United States': 'USA',
    'United Kingdom': 'UK',
    'England': 'UK',
    'Great Britain': 'UK'
}
df1['origin'].apply(lambda lst: [x if x not in change_names.keys() else change_names[x] for x in lst])
```

>[!error] Короче все это муторно, как то глупо и не гибко получается. Страны называются по-разному, Вьетнам либо слитно, либо раздельно, штаты и бриташки тоже. Надо что-то делать.

> Заменим список стран на некоторые коды стран, чтобы было какое то единообразие.

Также, возможно в БД добавить такую таблицу, но необязательно. Можно будет просто в нужном виде на сайте уже переводить коды стран в их названия. В конце концов БД не про хранение стран.

![[Pasted image 20231219132033.png]]
Попробуем не разбивать по запятым, т.к. там обычно тогда указан город и страна. Будем разбивать только по 'and', остальное преобразуем библиотекой.

```python
def test(row):
	standard_names = coco.convert(names=row, to='name_short')
	print("old: ", row, "New: ", standard_names)
df1.apply(lambda row: test(row['origin']), axis=1)
```
Вроде неплохо, но, он не находит штат-USA, всех их считает неизвестными

Вообщем делаем следующее. Единственная кошка с 'Unknown' - это Бирма (или Мьянма). Будем использовать библиотеку:
```python
!pip install country_converter
import country_converter as coco
```
Выполним следующее
```python
def process_row(lst):
	res = []
	for elem in lst:
	if 'USA' in elem:
		res.append('USA')
	elif 'Kuril Islands' in elem:
		res.append('Russia')
	elif 'Scotland' in elem:
		res.append('UK')
	elif 'Unknown' in elem:
		res.append('Myanmar')
	else:
		res.append(elem)
	res = [e.strip() for e in res]
	return res
df1['origin'] = df1['origin'].apply(process_row)
```
Тем самым уберем лишнее. Шотландию не находит, страной не считает.

Затем 
```python
def test(row):
	standard_names = coco.convert(names=row, to='ISO3')
	if type(standard_names) != list:
	standard_names = [standard_names]
	print("old: ", row, "New: ", standard_names)
return standard_names

# получить номера
def getNumOfCountries(lst):
	res = []
	for elem in lst:
	res.append(countries.get(elem).numeric)
	print(res)
df1.apply(lambda row: getNumOfCountries(row['origin']), axis=1)
```
Переведем все к одному виду.


>[!warning] Все отлично. Вот только пересечение состоит только из 28 пород, они отличаются сильнее, чем я думал....

Ну хорошо, пускай будет так. У нас есть пересечение. И есть названия из `df2`, которые не в пересечении. Работаем с `df1`, где основные данные. Если название в нем принадлежит пересечению - то все окей. Если нет, то заменяем на название из `df2`, и увеличиваем индекс этого массива названий. В итоге получим `df1`, где пересечение уже будет полное.

> Для больших файлов рекомендуется на загружать с гугл диска. Вот как это делается (добавить гифку)



### Данные с изображениями

> есть 80 мб csv с ссылками на изображения.

Из архива идентичный + 2 гб картинок

В плане картинок он выглядит так:
![[Pasted image 20231219111956.png]]
Тут список из сайта приюта, поэтому породы повторяются. Кроме того, тут в некоторых есть несколько разных фото (см. на /1 /2 /3 и т.д.). Остальное по большей части это просто 'full/large/small'. 
Поэтому нужно следующее:
- вытащить только уникальные ссылки, без размера. Для размера можно задавать "&width=600", это нет смысла хранить в базе данных. Тем более у некоторых задано 600, хотя максимум у них 500
- составить список всех уникальных ссылок на картинки для каждой породы
- возможно выбрать и отдельным полем сделать 'main_image' и отдельно полный список. В бд sql пока непонятно как, либо просто id - image_link. В mongo скорее всего список.






```python
!pip install pycountry
valid_countries = [country.name for country in pycountry.countries]

valid_countries
import pandas as pd
import pycountry

# Функция для обработки каждой строки
def process_row(row):
    if 'and' in row:
        country_list = [item.strip() for item in row.split('and')]
    elif ',' in row:
        country_list = [item.strip() for item in row.split(',')]
    else:
        country_list = [row.strip()]

    # Получение списка валидных стран с использованием pycountry
    valid_countries = [country.name for country in pycountry.countries]

    # Фильтрация только названий стран
    filtered_countries = list(filter(lambda x: x in valid_countries, country_list))

    return filtered_countries

# Применение функции к столбцу
df['column_name'] = df['column_name'].apply(process_row)

# Вывод результата
print(df)
```



